<!DOCTYPE html>
<html lang="en-us">

<head>
  
    <title>Scala 基础笔记 | Give me five</title>
    <meta name="DC.Title" content="Scala 基础笔记">
  

  
    <meta name="DC.Date" content="2013/08/10">
  

  
    <meta name="DC.Creator" content="Jiafeng Cao">
  

  
    <meta name="DC.Language" content="en">
  

  
    <meta name="DC.Description" content="控制结构和函数  赋值动作本身是没有值的。  var a = 1 scala&amp;gt; val nn = (a&#43;=1) nn: Unit = ()  scala 支持函数。只要函数不是递归的，就不需要指定返回类型。 异常中 throw 有特殊的类型 Nothing。  类、对象以及特质  下面代码中，_ 是什么意思？  class Person { var name: String = _ }  类型投影？ 在内嵌类中访问外部类？ 定义只读属性时,  val attr private var privateAttr &#43; def attar = privateAttr   选择哪个？其他更好的方案？
 类的伴生对象，可以访问类的私有成员。 类和其伴生对象可以相互访问私有特性？ 单例对象和伴生对象的关系？ 扩展类  使用 extends 关键字扩展类。 可以将类、字段、方法声明为 final，以确保其不会被重写。注：java 中的 final 意思与 val 类似，表示不可变。  重写方法  使用 override 修饰符来重写一个 非抽象方法 （那抽象方法？）。 使用 super 关键字来调用超类的方法。  类型检查和转换  o.">
  

  
    <meta name="DC.Identifier" content="/notes/scala-basics/">
  

  
    <meta name="keywords" content="scala,">
  

  

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../../css/style.css" />
  <link rel="stylesheet" href="../../css/fonts.css" />
</head>

    <a class="skip-main" href="#main">Skip to main content</a>
        <nav>
      <h1> Give me five </h1>
      <div>
      
      
      
      
        <a href="../../" title="Home">home</a>
      
      
        <a href="../../posts/" title="Posts">posts</a>
      
      
        <a href="../../notes/" title="Notes">notes</a>
      

      
      
        <a href="../../index.xml" title="RSS">rss</a>
      
      </div>
    </ul>
  </nav>




<main id="main">
<header>
    
        <h1>Scala 基础笔记</h1>
    

    
        
            Jiafeng Cao
        
         2013/08/10 
    

    
</header>

<article>


<h3 id="控制结构和函数">控制结构和函数</h3>

<ul>
<li>赋值动作本身是没有值的。</li>
</ul>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala">  <span style="color:#fb660a;font-weight:bold">var</span> a <span style="color:#fb660a;font-weight:bold">=</span> <span style="color:#0086f7;font-weight:bold">1</span>
  scala&gt; <span style="color:#fb660a;font-weight:bold">val</span> nn <span style="color:#fb660a;font-weight:bold">=</span> (a+=<span style="color:#0086f7;font-weight:bold">1</span>)
  nn<span style="color:#fb660a;font-weight:bold">:</span> <span style="color:#cdcaa9;font-weight:bold">Unit</span> = ()</code></pre></div>
<ul>
<li>scala 支持函数。只要函数不是递归的，就不需要指定返回类型。</li>
<li>异常中 throw 有特殊的类型 <code>Nothing</code>。</li>
</ul>

<h3 id="类-对象以及特质">类、对象以及特质</h3>

<ul>
<li>下面代码中，<code>_</code> 是什么意思？</li>
</ul>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala">  <span style="color:#fb660a;font-weight:bold">class</span> Person {
      <span style="color:#fb660a;font-weight:bold">var</span> name<span style="color:#fb660a;font-weight:bold">:</span> <span style="color:#cdcaa9;font-weight:bold">String</span> = <span style="color:#fb660a;font-weight:bold">_</span>
  }</code></pre></div>
<ul>
<li>类型投影？</li>
<li>在内嵌类中访问外部类？</li>
<li>定义只读属性时,

<ul>
<li><code>val attr</code></li>
<li><code>private var privateAttr</code> + <code>def attar = privateAttr</code></li>
</ul></li>
</ul>

<p>选择哪个？其他更好的方案？</p>

<ul>
<li>类的伴生对象，可以访问类的私有成员。</li>
<li>类和其伴生对象可以相互访问私有特性？</li>
<li>单例对象和伴生对象的关系？</li>
<li>扩展类

<ul>
<li>使用 <code>extends</code> 关键字扩展类。</li>
<li>可以将类、字段、方法声明为 <code>final</code>，以确保其不会被重写。注：java 中的 <code>final</code> 意思与 <code>val</code> 类似，表示不可变。</li>
</ul></li>
<li>重写方法

<ul>
<li>使用 <code>override</code> 修饰符来重写一个 <strong>非抽象方法</strong> （那抽象方法？）。</li>
<li>使用 <code>super</code> 关键字来调用超类的方法。</li>
</ul></li>
<li>类型检查和转换

<ul>
<li><code>o.isInstanceOf[C]</code></li>
<li><code>o.asInstanceOf[C]</code></li>
<li><code>classOf[C]</code></li>
</ul></li>
</ul>

<p>通常，模式匹配是更好的选择。[?]
- 受保护的字段和方法
  - 使用 <code>protected</code> 声明声明字段或方法，这样，就只能被子类访问。
  - 类所属的包不能访问 <code>protected</code> 成员。
  - <code>protect[this]</code> 将访问权限限制在当前对象，就像 <code>private[this]</code>。
- 超类的构造
  - 只有主构造器才能调用超类构造器，像这样:</p>

<pre><code>   class Employee(name: String, age: Int, val salary: Double) extends Person(name, age)
</code></pre>

<p>类似的 java 代码如下：</p>

<pre><code>    public class Employee extends Person {
        private final double salary;
        public Employee(String name, int age, double salary){
            super(name, age);
            this.salary = salary;
        }
    }
</code></pre>

<ul>
<li>Scala 可以扩展 Java 类，但其主构造器必须调用超类的某一构造器方法。</li>
<li>重写字段

<ul>
<li>scala 字段由一个私有字段和取值器/改值器方法构成。</li>
<li>一个val（或一个不带参数的 def）可以被另一个同名的 val 字段重写。更多情况如下：</li>
<li>def 只能重写另一个 def</li>
<li>val 只能重写另一个 val 或不带参数的 def</li>
<li>var 只能重写另一个抽象的 var</li>
</ul></li>

<li><p>匿名子类 [?]</p>

<ul>
<li>通过<strong>包含带有定义或重写的代码块</strong>来创建。比如：</li>
</ul>

<pre><code>class Person(val name:String)
val alien = new Person(&quot;Fred&quot;) {
    def greeting = &quot;Hello, my name is Fred!&quot;
}
</code></pre>

<p>该匿名子类的类型为 <code>Person{def greeting: String}</code>。注：技术上，上述代码会创建一个 结构类型[?] 的对象。</p></li>

<li><p>抽象类</p>

<ul>
<li>使用 <code>abstract</code> 关键字来标记不能被实例化的类。</li>
<li>抽象方法不需要使用 <code>abstract</code> ，只需省去其方法体。</li>
<li>如果一个类存在抽象方法，此类必须声明为 <code>abstract</code> 。</li>
<li>子类中，重写超类的抽象方法 不需要使用 <code>oberride</code> 关键字。</li>
</ul></li>

<li><p>抽象字段</p>

<ul>
<li>类可以拥有抽象字段（没有初始值，即表示其是抽象字段）。</li>
<li>生成的 java 类不带该字段。</li>
<li>具体的子类必须重写抽象字段，无需使用 <code>override</code> 。</li>
<li>也可用匿名子类来定制。</li>
</ul></li>

<li><p>构造顺序和提前定义 [?]</p></li>

<li><p>Scala 继承层级</p>

<ul>
<li><code>Boolean Byte Char Short Int Long Float Double Unit</code> 都扩展自 <code>AnyVal</code> 。</li>
<li>所有其他类都扩展自 <code>AnyRef</code>。</li>
<li><code>AnyVal</code> 和 <code>AnyRef</code> 扩展自 <code>Any</code> 。<code>Any</code> 是整个继承体系的根节点。</li>
<li>所有 Scala 类都实现了 <code>ScalaObject</code> 标记接口。</li>
<li><code>Nothing</code> 和 <code>Null</code> 类型都直接扩展自 <code>Any</code> 。<strong><code>Nothing</code> 是所有类型的子类型，没有实例；<code>Null</code> 是所有非值类型的子类型，其只有一个实例，即 <code>null</code>（所以，可以将 <code>null</code> 赋值给任何引用，但不能赋值给值类型）。</strong></li>
</ul></li>

<li><p>对象相等性</p>

<ul>
<li><code>AnyRef</code> 的 <code>eq</code> 方法检查应用是否指向同一个对象。</li>
<li><code>AnyRef</code> 的 <code>euqals</code> 方法直接调用 <code>eq</code> 方法。</li>
<li>当实现一个类时，应该考虑是否重写 <code>equals</code> 方法。</li>
<li>若重写了 <code>equals</code> 方法，还应重写 <code>hashCode</code> 方法。</li>
</ul></li>
</ul>

<blockquote>
<p>确保重写的 <code>equals</code> 方法参数类型为 <code>Any</code> 。重写 <code>equals</code> 和 <code>hashCode</code> 并不是一种义务。</p>
</blockquote>

<ul>
<li>特质与类的两个区别点

<ol>
<li>特质不能有类参数</li>
<li>特质中，对 super 的处理遵循 linearization</li>
</ol></li>
</ul>

<h2 id="协变-逆变">协变、逆变</h2>

<ul>
<li><code>Array</code> 不是协变的，所以</li>
</ul>

<pre><code>  val a: Array[SubClass] = Array(...)
  val b: Array[SuperClass] = a
</code></pre>

<h3 id="array-的几个关键点">Array 的几个关键点</h3>

<ul>
<li>Scala 中的 <code>Array</code> 和 Java 中的没什么不同，只不过 Scala 给 <code>Array</code> 赋予了两个隐式转换，
一个是到 <code>ArrayOps</code>，一个是到 <code>WrappedArray</code></li>
<li>不能简单的使用 <code>==</code> 来判断两个 array 是否相等，可以用 <code>array.sameElements(other)</code> 方法</li>
</ul>

<h2 id="list-概念-操作">List 概念、操作</h2>

<ul>
<li>List 是不可变的，且是递归形式的。</li>
<li>通过 <code>Nil</code> 和 操作符 <code>::</code> 来构造。例如：</li>
</ul>

<pre><code>  1 :: 2 :: 3 :: 4 :: Nil
</code></pre>

<ul>
<li>三个最重要的方法：<code>head, tail, isEmpty</code></li>
<li>List 上的模式匹配：

<ul>
<li>Nil</li>
<li>x :: xs</li>
<li>List(p1, p2, &hellip;, pn)</li>
</ul></li>
<li><code>length, last, init, take, drop</code> 以及 <code>list(n)</code></li>
<li><code>list1 ++ list2</code>, <code>list updated (n, x)</code></li>
<li><code>filter, takeWhile, filterNot, dropWhile, partition, span</code></li>
</ul>

<h2 id="codeing-tips">Codeing Tips</h2>

<ul>
<li>Use expressions not statements. In Scala, a lot of code can be written as small methods of one expression, for elegance, and code maintenance.</li>
<li>Prefer Immutability. Creating immutable classes drastically reduces the number of potential runtime issues.it’s safest to stay immutable, when in doubt.</li>
</ul>

<p><em>Difference between an immutable object and an immutable reference</em>, the immutability of the reference doesn’t affect whether the object referred to is immutable.</p>

<ul>
<li>HASHCODE AND EQUALS SHOULD ALWAYS BE PAIRED. If x == y, then x.## == y.##(<code>##</code> is an alias of <code>hashCode</code>)

<ul>
<li>如果两个对象相等，那么它们应该有相同的 <code>hashCode</code>。</li>
<li>在对象的生命周期内，<code>hashCode</code> 不应该有所改变。</li>
<li>当发送对象到另外一个 JVM 时，对象相等性的计算应该使用哪些对两个JVM都可用的属性（绝大部分情况下，也就是对象内部的属性）。</li>
</ul></li>
<li>Use <code>None</code> instead of <code>null</code> .</li>
<li>Override methods with named parameters and default values.</li>
</ul>

</article>
</main>

    <footer>
    <hr>
      
  <link rel="stylesheet" href="../../css/vs.min.css">
  <script src="../../js/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>


  <script>
    
    let elements = document.getElementsByClassName("highlight");
    for (let element_id = 0; element_id < elements.length; element_id++) {
      const element = elements[element_id];
      
      element.firstChild.setAttribute("style", "");
      
      let language = element.firstChild.firstChild.getAttribute("data-lang");
      if (language !== null) {
          element.firstChild.firstChild.setAttribute("class", language);
      }
    }
  </script>

  <script>
    const code = document.querySelectorAll("code");
    [...code].forEach(el => el.textContent = el.textContent.replace(/^\n/,''));
  </script>

      <p>
        Last updated May 08 2021
      </p>
      <p>
        
      </p>
      <br>
    </footer>
  </body>
</html>

