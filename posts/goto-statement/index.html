<!DOCTYPE html>
<html lang="en-us">

<head>
  
    <title>[Structured Programming with Goto Statement] 笔记 | Give me five</title>
    <meta name="DC.Title" content="[Structured Programming with Goto Statement] 笔记">
  

  
    <meta name="DC.Date" content="2014/10/10">
  

  
    <meta name="DC.Creator" content="Jiafeng Cao">
  

  
    <meta name="DC.Language" content="en">
  

  
    <meta name="DC.Description" content="Structured Programming with goto Statements 是 Donald E. Knuth 于 1974 年的写作的一篇文章。 原始的 pdf 格式效果不好，互联网上存在一个 html 版本。
文章试图以一种易于理解的方式说明 goto 的正反两面。 同时，为了说明 goto 不同的使用情况，文章还讨论了很多例子程序。
goto 历史 从60年代开始，程序员开始避免使用 goto，尤其是在 Edsger Dijkstra 的 A Case against the GO TO Statement之后，goto 是有害的这一论调已经达成了广泛的共识。 然而程序员和语言的设计者仍然会需要 &amp;ldquo;goes/jump to&amp;rdquo; 这种类似 goto 的编程方式。
一个搜索的例子 一个典型的程序：假设我们想搜索一个表 A[1] ... A[m]，其中的值各不相同；如果值 x 不在表中出现，我们想把它插入到其中。 另外，还假设另一个有数组 B，其中 B[i] 记录了我们搜索 A[i] 的次数。 我们可能会通过如下的程序来解决这个问题：
Example 1
for i:=1 step 1 until m do if A[i] = x then goto found fi; not found: i:= m &#43; 1; m := i; A[i] := x; B[i] := 0; found: B[i] := B[i] &#43; 1;  如果禁止使用 goto，可以这样做（把 for 循环展开为赋值和 while 循环）：">
  

  
    <meta name="DC.Identifier" content="/posts/goto-statement/">
  

  
    <meta name="keywords" content="goto,">
  

  

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../../css/style.css" />
  <link rel="stylesheet" href="../../css/fonts.css" />
</head>

    <a class="skip-main" href="#main">Skip to main content</a>
        <nav>
      <h1> Give me five </h1>
      <div>
      
      
      
      
        <a href="../../" title="Home">home</a>
      
      
        <a href="../../posts/" title="Posts">posts</a>
      
      
        <a href="../../notes/" title="Notes">notes</a>
      

      
      
        <a href="../../index.xml" title="RSS">rss</a>
      
      </div>
    </ul>
  </nav>




<main id="main">
<header>
    
        <h1>[Structured Programming with Goto Statement] 笔记</h1>
    

    
        
            Jiafeng Cao
        
         2014/10/10 
    

    
</header>

<article>


<p><a href="http://cs.sjsu.edu/~mak/CS185C/KnuthStructuredProgrammingGoTo.pdf">Structured Programming with <code>goto</code> Statements</a> 是 Donald E. Knuth 于 1974 年的写作的一篇文章。
原始的 pdf 格式效果不好，互联网上存在一个 <a href="http://www.kohala.com/start/papers.others/knuth.dec74.html">html 版本</a>。</p>

<p>文章试图以一种易于理解的方式说明 <code>goto</code> 的正反两面。
同时，为了说明 <code>goto</code> 不同的使用情况，文章还讨论了很多例子程序。</p>

<h3 id="goto-历史">goto 历史</h3>

<p>从60年代开始，程序员开始避免使用 <code>goto</code>，尤其是在 Edsger Dijkstra 的 <a href="http://www.cs.utexas.edu/~EWD/transcriptions/EWD02xx/EWD215.html">A Case against the GO TO Statement</a>之后，<code>goto</code> 是有害的这一论调已经达成了广泛的共识。
然而程序员和语言的设计者仍然会需要 &ldquo;goes/jump to&rdquo; 这种类似 <code>goto</code> 的编程方式。</p>

<h3 id="一个搜索的例子">一个搜索的例子</h3>

<p>一个典型的程序：假设我们想搜索一个表 <code>A[1] ... A[m]</code>，其中的值各不相同；如果值 <code>x</code> 不在表中出现，我们想把它插入到其中。
另外，还假设另一个有数组 <code>B</code>，其中 <code>B[i]</code> 记录了我们搜索 <code>A[i]</code> 的次数。
我们可能会通过如下的程序来解决这个问题：</p>

<p><em>Example 1</em></p>

<pre><code>for i:=1 step 1 until m do
  if A[i] = x then goto found fi;
not found:
  i:= m + 1;
  m := i;
  A[i] := x;
  B[i] := 0;
found:
  B[i] := B[i] + 1;
</code></pre>

<p>如果禁止使用 <code>goto</code>，可以这样做（把 for 循环展开为赋值和 while 循环）：</p>

<p><em>Example 1a</em></p>

<pre><code>i := 1;
while i &lt;= m and A[i] != x do
  i := i + 1;
if i &gt; m then
  m := i;
  A[i] := x;
  B[i] := 1;
else
  B[i] := B[i] + 1;
fi;
</code></pre>

<p>下面列出的方法通过修改数据结构达成了更好的结果：</p>

<p><em>Example 2</em></p>

<pre><code>A[m+1] := x;
i:= 1;
while A[i] != x do
  i := i + 1;
if i &gt; m then
  m := i;
  B[i] := 1;
else
  B[i] := B[i] + 1;
fi;
</code></pre>

<h3 id="效率">效率</h3>

<p>经验表明：非 IO-bound 程序源代码的 3% 决定了其绝大部分的运行时间。内循环的运行速度影响着整个程序的运行速度。</p>

<p><strong>尽可能的去修改程序和数据结构来优化内循环的行为</strong>。这么做出于以下三个目的：
1. 优化过程不会花费很长时间，因为内循环一般都很简短。
2. 取得的效果是可观的。
3. 程序的其他部分可以不那么有效率，以换取可读性和调试的简便。</p>

<p><em>Example 1</em> 中，就可能将循环从 <code>1</code> 到 <code>m</code> 变为从 <code>m</code> 到 <code>1</code>，因为与零比较来的更简单。
<em>Example 2</em> 可以通过加速来提高效率。</p>

<p><em>Example 2a</em></p>

<pre><code>A[m+1] := x;
i := 1;
goto test;
loop:
  i := i + 2;
test:
  if A[i] = x then goto found fi;
  if A[i+1] != x then goto loop fi;
  i := i + 1;
found:
  if i &gt; m then
    m := i;
    B[i] := 1;
  else
    B[i] := B[i] + 1;
  fi;
</code></pre>

<h3 id="错误退出">错误退出</h3>

<p>上述的例子漏掉了一个重要的问题，没有对 <code>m</code> 做检查（<code>m := i</code> 赋值可能出现溢出）。
软件工程中，<strong>对数据有效性的检查是非常重要的。</strong>
现在说明这个情况，是因为 <em>error exit</em> 是一类重要的 <code>goto</code>。</p>

<p>有时候，错误退出会跨越多层控制栈，而最优雅的方式是直接使用 <code>goto</code> 或与之等效的方法；
这样，程序的中间层就可以假设没有错误发生。</p>

<h3 id="下标检查">下标检查</h3>

<p>在测试期，把下表检查编译成机器码，而在真正的运行期，又取消或这抑制这样的检查；
这就好比，一个水手在训练的时候穿着他的救生服，而下水远航时，却把救生服落在一边。
<strong>下标检查是很有必要的，但不是必须的。</strong>
比如，在 for 循环里面做检查增加了程序负担，因为非常确定在没有到达循环结束之前，下标都是有效的。
拿水手类比，如果水手知道救生服很贵，或者他本身是一个非常优秀的水手，那相比其他危险，救生服就不那么重要了。</p>

<h3 id="再一个例子-哈希">再一个例子：哈希</h3>

<p>假设上述的例子基于标准的哈希技术：<code>h(x)</code> 是一个产生值在 <code>1</code> 和 <code>m</code> 之间的哈希函数，并且 <code>x != 0</code>，
并且 <code>m</code> 大于表中条目的个数以保证表中至少含有一个“空位置”，“空位置”用零表示。</p>

<p><em>Example 3</em></p>

<pre><code>i := h(x);
while A[i] != 0 do
  begin
    if A[i] = x then goto found fi;
    i := i - 1;
    if i = 0 then i := m fi;
  end;
not found:
  A[i] := x;
  B[i] := 0;
found:
  B[i] := B[i] + 1;
</code></pre>

<p>这样一来，<em>Example 2</em> 的小技巧就不适用了。
然而，可以用 <em>Example 1a</em> 的方法来消除 <code>goto</code>：<code>while A[i] != 0 and A[i] != x do ...</code>，
之后，再做一个简单的条件终止检测。</p>

<pre><code>i := h(x)
while A[i] != 0 and A[i] != x do
  begin
    i := i - 1;
    if i = 0 then i :=m fi;
  end;
if A[i] = 0 then
  A[i] := x;
  B[i] := 1;
else
  B[i] := B[i] + 1;
fi;
</code></pre>

<p>这个版本可能更容易阅读，然而，相比 _Example 3_，它做了多余的条件终止检测；
程序的关键部分，应当避免这种情况。</p>

<p>为什么要担心这个多余的检测呢？毕竟它并不在 while-loop 里面。
这是因为，while-loop 并不真的会表现为一个循环：对于一个合适的 <code>h</code> 和 <code>m</code>，操作 <code>i := i - 1</code> 会很少执行，
相较而言，这个多余的检测就不能再被忽略了，尤其是当这个搜索代码在整个程序起主导作用。</p>

<p>多数情况下，由 <code>A[i] = x</code> 终止循环发生的更频繁，洞察了这一行为，代码可以变换如下：</p>

<p><em>Example 3a</em></p>

<pre><code>i := h(x)
while A[i] != x do
  begin
    if A[i] = 0 then
      A[x] := x;
      B[i]: = 0;
      goto found;
    fi;
    i := i - 1;
    if i = 0 then i := m fi;
  end
found: B[i] := B[i] + 1;
</code></pre>

<p>这里就是一个延时优化的例子：当获得了更多关于程序行为的信息，再去优化程序。</p>

<p>如果 while-loop 变成了一个影响整个程序的内循环，那情况又变了。
多余的那个条件终止检测就可以忽略不计，而 <code>if i = 0</code> 就影响颇大，我们可能想避免这个几乎总是为 false 的检测。
加上这个假设，程序又应该加以如下的变换：</p>

<p><em>Example 3b</em></p>

<pre><code>A[0] = 0 // add a new element
i := h(x)
while A[i] != x do
    if A[i] != 0 then
      i := i - 1
    else if i = 0 then
      i := m
    else
      A[x] := x;
      B[i]: = 0;
      goto found;
    fi;
  end
found: B[i] := B[i] + 1;
</code></pre>

<h3 id="一个关于文本扫描的例子">一个关于文本扫描的例子</h3>

<p><em>Example 4</em></p>

<pre><code>x := read-char;
if x = slash then
  x:= read-char;
  if x = slash then
    carriage-return;
    goto char-processed;
  else
    tabulate;
  fi;
fi;
write-char(x);
if x = period then
  write-char space fi;
fi;
char-processed:
</code></pre>

<h3 id="树搜索">树搜索</h3>

<p><em>Example 5</em></p>

<pre><code>compare:
  if A[i] &lt; x then
    if L[i] != 0 then
      i := L[i];
      goto compare;
    else
      L[i] := j;
      goto insert;
    fi;
  else
    if R[i] != 0 then
      i := R[i];
      goto compare;
    else
      R[i] := j;
      goto insert;
    fi;
  fi;
insert:
  A[j] := x;
L[j] := 0;
R[j] := 0;
j := j+1;
</code></pre>

<h3 id="系统化的消除-goto">系统化的消除 goto</h3>

<p>大多数情况下，程序结构可以很好地用 _顺序组合_，_条件_，_迭代_以及 <em>case 多路分支</em> 来描述;
无约束的 <code>goto</code> 使得程序结构难以描述，并且往往是程序形式化出错的症状。
但 <code>goto</code> 存在与否并不是关键点，重要的是冰山下的程序结构。
人们总是过于强调去消除 <code>goto</code> ，而忽略了真正的问题，
程序员们真正想要的是将程序组织成易于理解的代码，而避免那种会搞乱程序的东西只是会有利于达到这一目的而已。
构造一个程序而无需想到要使用 <code>goto</code> 才是程序员真正要做到的。</p>

<h3 id="事件表征">事件表征</h3>

<p>通过事件来代替 <code>goto label</code></p>

<pre><code>A)      loop until &lt;event&gt;1 or ... or &lt;event&gt;n:
                  &lt;statement list&gt;0;
        repeat;
        then &lt;event&gt;1 =&gt; &lt;statement list&gt;1;
                        . . .
             &lt;event&gt;n =&gt; &lt;statement list&gt;n;
        fi;
B)      begin until &lt;event&gt;1 or ... or &lt;event&gt;n;
                  &lt;statement list&gt;0;
        end;
        then &lt;event&gt;1 =&gt; &lt;statement list&gt;1;
                        . . .
             &lt;event&gt;n =&gt; &lt;statement list&gt;n;
        fi;
</code></pre>

<p><em>Example 5b</em></p>

<pre><code>loop until left leaf hit or right leaf hit:
    if A[i] &lt; x
    then if L[i] != 0 then i := L[i];
        else left leaf hit fi;
    else if R[i] != 0 then i := R[i];
        else right leaf hit fi;
    fi;
repeat;
then left leaf hit =&gt; L[i] : = j;
          right leaf hit =&gt; R[i]: = j;
fi
A[j] := x; L[j] := 0; R[j] := 0; j := j+1;
</code></pre>

<p><em>Example 5c</em></p>

<pre><code>loop until leaf replaced:
    if A[i] &lt; x
    then if L[i] != 0 then i := L[i]
        else L[i] := j; leaf replaced fi;
    else if R[i] != 0 then i := R[i]
        else R[i] := j; leaf replaced fi;
    fi;
repeat
A[j] := x; L[j] := 0; R[j] := 0; j := j+1;
</code></pre>

<p>如果事件还可以扩展从而带有参数，<em>Example 1 ~ 3</em> 就可以通过事件的方式来抽象化：</p>

<pre><code>begin until found:
    search table for x and insert it if not present;
end;
then found (integer j) =&gt; B[j] := B[j]+1;
fi;
</code></pre>

<p>这和回调机制类似。</p>

<h3 id="消除递归">消除递归</h3>

<p>以中序遍历作为例子。</p>

<p><em>Example 6：基本的递归方法</em></p>

<pre><code>procedure treeprint(t); integer t; value t;
  if t != 0 then
    treeprint(L[t]);
    print(A[t]);
    treeprint(R[t]);
  fi;
</code></pre>

<p><em>Example 6a：利用 goto 消除函数尾的递归调用</em></p>

<pre><code>procedure treeprint(t); integer t; value t
L: if t != 0 then
      treeprint(L[t]);
      print(A[t]);
      t := R[t];
      go to L;
    fi;
</code></pre>

<p><em>Example 6b: 消除 goto</em></p>

<pre><code>procedure treeprint(t); integer t; value t;
  loop while t != 0:
    treeprint (L[t]);
    print (A[t]);
    t := R[t];
  repeat;
</code></pre>

<p><em>Example 6c: 再消除内部的递归</em></p>

<pre><code>procedure treeprint(t); integer t; value t;
  begin
    integer stack S; S := empty;
L1: loop while t != 0:
      S &lt;= t; t := L[t]; go to L1;
L2:   t &lt;= S;
      print(A[t]);
      t := R[t];
    repeat
    if nonempty(S) then go to L2 fi;
  end
</code></pre>

<p>转换过程中，使用了两个重要的消除原则：
1. 对于尾调用来说，只需简单的 goto 到其开始执行位置。从而，有 <em>Example 6</em> 到 <em>Example 6a</em> 的转换。
2. 对于内嵌的递归调用，保存每一次递归的局部变量，到达递归深度之后，再从底向上执行。从而，有 <em>Example 6b</em> 到 <em>Example 6c</em> 的转换。</p>

<p>可以发现，再进一步对 <em>Example 6c</em> 进行 <code>goto</code> 消除，可以实现基于栈的中序遍历，所达到的执行效果是一样的。</p>

<h3 id="程序转换">程序转换</h3>

<p>程序设计中，一种可行的解决方式是：首先完成一个结构优美但效率可能很低的程序 P；然后等价的转换程序，直至达到一定的效率，变成最终的程序 Q，当然这些转换过程必须是直观且可信的。这个过程之所以可行，是因为程序员知道每一步转换应该优化程序的哪个部分，以及应该优化到什么程度，这一点和延迟优化也是有关系的。</p>

<p>目前为止，这篇文章已经提到了几种转换：
1. 加速循环过程（_Example 2a_）
2. 把尾调用变成 <code>goto</code> 或其等价的形式（_Example 6a_）
3. 使用栈来模拟递归（_Example 6c_）</p>

<p>另外一种著名的方法是 _将不变的子表达式从循环中移除_。</p>

</article>
</main>

    <footer>
    <hr>
      
  <link rel="stylesheet" href="../../css/vs.min.css">
  <script src="../../js/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>


  <script>
    
    let elements = document.getElementsByClassName("highlight");
    for (let element_id = 0; element_id < elements.length; element_id++) {
      const element = elements[element_id];
      
      element.firstChild.setAttribute("style", "");
      
      let language = element.firstChild.firstChild.getAttribute("data-lang");
      if (language !== null) {
          element.firstChild.firstChild.setAttribute("class", language);
      }
    }
  </script>

  <script>
    const code = document.querySelectorAll("code");
    [...code].forEach(el => el.textContent = el.textContent.replace(/^\n/,''));
  </script>

      <p>
        Last updated Apr 08 2021
      </p>
      <p>
        
      </p>
      <br>
    </footer>
  </body>
</html>

